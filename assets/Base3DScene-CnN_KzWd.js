var _e=Object.defineProperty;var we=(r,e,t)=>e in r?_e(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var O=(r,e,t)=>we(r,typeof e!="symbol"?e+"":e,t);import{i as Te,e as w,j as F,T as v,Q as K,k as ie,l as P,R as Ee,m as Me,n as V,c as fe,o as me,p as U,q as be,r as q,s as Ae,N as Re,t as Se,D as Ie,u as Z,I as Ce,S as te,v as Le,w as Ne,x as Pe,y as De,z as Oe,A as Ue,E as ke,F as ve,H as Fe,J as ze,K as Ge,W as Be,P as je,C,O as Q,U as He,d as Ye,B as Ke,L as Ve,f as Ze,g as Xe,M as We,h as oe,X as qe,Y as Qe}from"./index-D1NIF6BJ.js";const re={type:"change"},se={type:"start"},ge={type:"end"},Y=new Ee,ae=new Me,Je=Math.cos(70*V.DEG2RAD),M=new w,S=2*Math.PI,_={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},J=1e-6;class $e extends Te{constructor(e,t=null){super(e,t),this.state=_.NONE,this.enabled=!0,this.target=new w,this.cursor=new w,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.keyRotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:F.ROTATE,MIDDLE:F.DOLLY,RIGHT:F.PAN},this.touches={ONE:v.ROTATE,TWO:v.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this._lastPosition=new w,this._lastQuaternion=new K,this._lastTargetPosition=new w,this._quat=new K().setFromUnitVectors(e.up,new w(0,1,0)),this._quatInverse=this._quat.clone().invert(),this._spherical=new ie,this._sphericalDelta=new ie,this._scale=1,this._panOffset=new w,this._rotateStart=new P,this._rotateEnd=new P,this._rotateDelta=new P,this._panStart=new P,this._panEnd=new P,this._panDelta=new P,this._dollyStart=new P,this._dollyEnd=new P,this._dollyDelta=new P,this._dollyDirection=new w,this._mouse=new P,this._performCursorZoom=!1,this._pointers=[],this._pointerPositions={},this._controlActive=!1,this._onPointerMove=tt.bind(this),this._onPointerDown=et.bind(this),this._onPointerUp=st.bind(this),this._onContextMenu=ht.bind(this),this._onMouseWheel=ot.bind(this),this._onKeyDown=rt.bind(this),this._onTouchStart=at.bind(this),this._onTouchMove=ct.bind(this),this._onMouseDown=nt.bind(this),this._onMouseMove=it.bind(this),this._interceptControlDown=lt.bind(this),this._interceptControlUp=ut.bind(this),this.domElement!==null&&this.connect(),this.update()}connect(){this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointercancel",this._onPointerUp),this.domElement.addEventListener("contextmenu",this._onContextMenu),this.domElement.addEventListener("wheel",this._onMouseWheel,{passive:!1}),this.domElement.getRootNode().addEventListener("keydown",this._interceptControlDown,{passive:!0,capture:!0}),this.domElement.style.touchAction="none"}disconnect(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.domElement.removeEventListener("pointercancel",this._onPointerUp),this.domElement.removeEventListener("wheel",this._onMouseWheel),this.domElement.removeEventListener("contextmenu",this._onContextMenu),this.stopListenToKeyEvents(),this.domElement.getRootNode().removeEventListener("keydown",this._interceptControlDown,{capture:!0}),this.domElement.style.touchAction="auto"}dispose(){this.disconnect()}getPolarAngle(){return this._spherical.phi}getAzimuthalAngle(){return this._spherical.theta}getDistance(){return this.object.position.distanceTo(this.target)}listenToKeyEvents(e){e.addEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=e}stopListenToKeyEvents(){this._domElementKeyEvents!==null&&(this._domElementKeyEvents.removeEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=null)}saveState(){this.target0.copy(this.target),this.position0.copy(this.object.position),this.zoom0=this.object.zoom}reset(){this.target.copy(this.target0),this.object.position.copy(this.position0),this.object.zoom=this.zoom0,this.object.updateProjectionMatrix(),this.dispatchEvent(re),this.update(),this.state=_.NONE}update(e=null){const t=this.object.position;M.copy(t).sub(this.target),M.applyQuaternion(this._quat),this._spherical.setFromVector3(M),this.autoRotate&&this.state===_.NONE&&this._rotateLeft(this._getAutoRotationAngle(e)),this.enableDamping?(this._spherical.theta+=this._sphericalDelta.theta*this.dampingFactor,this._spherical.phi+=this._sphericalDelta.phi*this.dampingFactor):(this._spherical.theta+=this._sphericalDelta.theta,this._spherical.phi+=this._sphericalDelta.phi);let n=this.minAzimuthAngle,s=this.maxAzimuthAngle;isFinite(n)&&isFinite(s)&&(n<-Math.PI?n+=S:n>Math.PI&&(n-=S),s<-Math.PI?s+=S:s>Math.PI&&(s-=S),n<=s?this._spherical.theta=Math.max(n,Math.min(s,this._spherical.theta)):this._spherical.theta=this._spherical.theta>(n+s)/2?Math.max(n,this._spherical.theta):Math.min(s,this._spherical.theta)),this._spherical.phi=Math.max(this.minPolarAngle,Math.min(this.maxPolarAngle,this._spherical.phi)),this._spherical.makeSafe(),this.enableDamping===!0?this.target.addScaledVector(this._panOffset,this.dampingFactor):this.target.add(this._panOffset),this.target.sub(this.cursor),this.target.clampLength(this.minTargetRadius,this.maxTargetRadius),this.target.add(this.cursor);let i=!1;if(this.zoomToCursor&&this._performCursorZoom||this.object.isOrthographicCamera)this._spherical.radius=this._clampDistance(this._spherical.radius);else{const o=this._spherical.radius;this._spherical.radius=this._clampDistance(this._spherical.radius*this._scale),i=o!=this._spherical.radius}if(M.setFromSpherical(this._spherical),M.applyQuaternion(this._quatInverse),t.copy(this.target).add(M),this.object.lookAt(this.target),this.enableDamping===!0?(this._sphericalDelta.theta*=1-this.dampingFactor,this._sphericalDelta.phi*=1-this.dampingFactor,this._panOffset.multiplyScalar(1-this.dampingFactor)):(this._sphericalDelta.set(0,0,0),this._panOffset.set(0,0,0)),this.zoomToCursor&&this._performCursorZoom){let o=null;if(this.object.isPerspectiveCamera){const a=M.length();o=this._clampDistance(a*this._scale);const c=a-o;this.object.position.addScaledVector(this._dollyDirection,c),this.object.updateMatrixWorld(),i=!!c}else if(this.object.isOrthographicCamera){const a=new w(this._mouse.x,this._mouse.y,0);a.unproject(this.object);const c=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),this.object.updateProjectionMatrix(),i=c!==this.object.zoom;const l=new w(this._mouse.x,this._mouse.y,0);l.unproject(this.object),this.object.position.sub(l).add(a),this.object.updateMatrixWorld(),o=M.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),this.zoomToCursor=!1;o!==null&&(this.screenSpacePanning?this.target.set(0,0,-1).transformDirection(this.object.matrix).multiplyScalar(o).add(this.object.position):(Y.origin.copy(this.object.position),Y.direction.set(0,0,-1).transformDirection(this.object.matrix),Math.abs(this.object.up.dot(Y.direction))<Je?this.object.lookAt(this.target):(ae.setFromNormalAndCoplanarPoint(this.object.up,this.target),Y.intersectPlane(ae,this.target))))}else if(this.object.isOrthographicCamera){const o=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),o!==this.object.zoom&&(this.object.updateProjectionMatrix(),i=!0)}return this._scale=1,this._performCursorZoom=!1,i||this._lastPosition.distanceToSquared(this.object.position)>J||8*(1-this._lastQuaternion.dot(this.object.quaternion))>J||this._lastTargetPosition.distanceToSquared(this.target)>J?(this.dispatchEvent(re),this._lastPosition.copy(this.object.position),this._lastQuaternion.copy(this.object.quaternion),this._lastTargetPosition.copy(this.target),!0):!1}_getAutoRotationAngle(e){return e!==null?S/60*this.autoRotateSpeed*e:S/60/60*this.autoRotateSpeed}_getZoomScale(e){const t=Math.abs(e*.01);return Math.pow(.95,this.zoomSpeed*t)}_rotateLeft(e){this._sphericalDelta.theta-=e}_rotateUp(e){this._sphericalDelta.phi-=e}_panLeft(e,t){M.setFromMatrixColumn(t,0),M.multiplyScalar(-e),this._panOffset.add(M)}_panUp(e,t){this.screenSpacePanning===!0?M.setFromMatrixColumn(t,1):(M.setFromMatrixColumn(t,0),M.crossVectors(this.object.up,M)),M.multiplyScalar(e),this._panOffset.add(M)}_pan(e,t){const n=this.domElement;if(this.object.isPerspectiveCamera){const s=this.object.position;M.copy(s).sub(this.target);let i=M.length();i*=Math.tan(this.object.fov/2*Math.PI/180),this._panLeft(2*e*i/n.clientHeight,this.object.matrix),this._panUp(2*t*i/n.clientHeight,this.object.matrix)}else this.object.isOrthographicCamera?(this._panLeft(e*(this.object.right-this.object.left)/this.object.zoom/n.clientWidth,this.object.matrix),this._panUp(t*(this.object.top-this.object.bottom)/this.object.zoom/n.clientHeight,this.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),this.enablePan=!1)}_dollyOut(e){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale/=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_dollyIn(e){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale*=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_updateZoomParameters(e,t){if(!this.zoomToCursor)return;this._performCursorZoom=!0;const n=this.domElement.getBoundingClientRect(),s=e-n.left,i=t-n.top,o=n.width,a=n.height;this._mouse.x=s/o*2-1,this._mouse.y=-(i/a)*2+1,this._dollyDirection.set(this._mouse.x,this._mouse.y,1).unproject(this.object).sub(this.object.position).normalize()}_clampDistance(e){return Math.max(this.minDistance,Math.min(this.maxDistance,e))}_handleMouseDownRotate(e){this._rotateStart.set(e.clientX,e.clientY)}_handleMouseDownDolly(e){this._updateZoomParameters(e.clientX,e.clientX),this._dollyStart.set(e.clientX,e.clientY)}_handleMouseDownPan(e){this._panStart.set(e.clientX,e.clientY)}_handleMouseMoveRotate(e){this._rotateEnd.set(e.clientX,e.clientY),this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const t=this.domElement;this._rotateLeft(S*this._rotateDelta.x/t.clientHeight),this._rotateUp(S*this._rotateDelta.y/t.clientHeight),this._rotateStart.copy(this._rotateEnd),this.update()}_handleMouseMoveDolly(e){this._dollyEnd.set(e.clientX,e.clientY),this._dollyDelta.subVectors(this._dollyEnd,this._dollyStart),this._dollyDelta.y>0?this._dollyOut(this._getZoomScale(this._dollyDelta.y)):this._dollyDelta.y<0&&this._dollyIn(this._getZoomScale(this._dollyDelta.y)),this._dollyStart.copy(this._dollyEnd),this.update()}_handleMouseMovePan(e){this._panEnd.set(e.clientX,e.clientY),this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd),this.update()}_handleMouseWheel(e){this._updateZoomParameters(e.clientX,e.clientY),e.deltaY<0?this._dollyIn(this._getZoomScale(e.deltaY)):e.deltaY>0&&this._dollyOut(this._getZoomScale(e.deltaY)),this.update()}_handleKeyDown(e){let t=!1;switch(e.code){case this.keys.UP:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateUp(S*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(0,this.keyPanSpeed),t=!0;break;case this.keys.BOTTOM:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateUp(-S*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(0,-this.keyPanSpeed),t=!0;break;case this.keys.LEFT:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateLeft(S*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(this.keyPanSpeed,0),t=!0;break;case this.keys.RIGHT:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateLeft(-S*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(-this.keyPanSpeed,0),t=!0;break}t&&(e.preventDefault(),this.update())}_handleTouchStartRotate(e){if(this._pointers.length===1)this._rotateStart.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),n=.5*(e.pageX+t.x),s=.5*(e.pageY+t.y);this._rotateStart.set(n,s)}}_handleTouchStartPan(e){if(this._pointers.length===1)this._panStart.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),n=.5*(e.pageX+t.x),s=.5*(e.pageY+t.y);this._panStart.set(n,s)}}_handleTouchStartDolly(e){const t=this._getSecondPointerPosition(e),n=e.pageX-t.x,s=e.pageY-t.y,i=Math.sqrt(n*n+s*s);this._dollyStart.set(0,i)}_handleTouchStartDollyPan(e){this.enableZoom&&this._handleTouchStartDolly(e),this.enablePan&&this._handleTouchStartPan(e)}_handleTouchStartDollyRotate(e){this.enableZoom&&this._handleTouchStartDolly(e),this.enableRotate&&this._handleTouchStartRotate(e)}_handleTouchMoveRotate(e){if(this._pointers.length==1)this._rotateEnd.set(e.pageX,e.pageY);else{const n=this._getSecondPointerPosition(e),s=.5*(e.pageX+n.x),i=.5*(e.pageY+n.y);this._rotateEnd.set(s,i)}this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const t=this.domElement;this._rotateLeft(S*this._rotateDelta.x/t.clientHeight),this._rotateUp(S*this._rotateDelta.y/t.clientHeight),this._rotateStart.copy(this._rotateEnd)}_handleTouchMovePan(e){if(this._pointers.length===1)this._panEnd.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),n=.5*(e.pageX+t.x),s=.5*(e.pageY+t.y);this._panEnd.set(n,s)}this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd)}_handleTouchMoveDolly(e){const t=this._getSecondPointerPosition(e),n=e.pageX-t.x,s=e.pageY-t.y,i=Math.sqrt(n*n+s*s);this._dollyEnd.set(0,i),this._dollyDelta.set(0,Math.pow(this._dollyEnd.y/this._dollyStart.y,this.zoomSpeed)),this._dollyOut(this._dollyDelta.y),this._dollyStart.copy(this._dollyEnd);const o=(e.pageX+t.x)*.5,a=(e.pageY+t.y)*.5;this._updateZoomParameters(o,a)}_handleTouchMoveDollyPan(e){this.enableZoom&&this._handleTouchMoveDolly(e),this.enablePan&&this._handleTouchMovePan(e)}_handleTouchMoveDollyRotate(e){this.enableZoom&&this._handleTouchMoveDolly(e),this.enableRotate&&this._handleTouchMoveRotate(e)}_addPointer(e){this._pointers.push(e.pointerId)}_removePointer(e){delete this._pointerPositions[e.pointerId];for(let t=0;t<this._pointers.length;t++)if(this._pointers[t]==e.pointerId){this._pointers.splice(t,1);return}}_isTrackingPointer(e){for(let t=0;t<this._pointers.length;t++)if(this._pointers[t]==e.pointerId)return!0;return!1}_trackPointer(e){let t=this._pointerPositions[e.pointerId];t===void 0&&(t=new P,this._pointerPositions[e.pointerId]=t),t.set(e.pageX,e.pageY)}_getSecondPointerPosition(e){const t=e.pointerId===this._pointers[0]?this._pointers[1]:this._pointers[0];return this._pointerPositions[t]}_customWheelEvent(e){const t=e.deltaMode,n={clientX:e.clientX,clientY:e.clientY,deltaY:e.deltaY};switch(t){case 1:n.deltaY*=16;break;case 2:n.deltaY*=100;break}return e.ctrlKey&&!this._controlActive&&(n.deltaY*=10),n}}function et(r){this.enabled!==!1&&(this._pointers.length===0&&(this.domElement.setPointerCapture(r.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.domElement.addEventListener("pointerup",this._onPointerUp)),!this._isTrackingPointer(r)&&(this._addPointer(r),r.pointerType==="touch"?this._onTouchStart(r):this._onMouseDown(r)))}function tt(r){this.enabled!==!1&&(r.pointerType==="touch"?this._onTouchMove(r):this._onMouseMove(r))}function st(r){switch(this._removePointer(r),this._pointers.length){case 0:this.domElement.releasePointerCapture(r.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.dispatchEvent(ge),this.state=_.NONE;break;case 1:const e=this._pointers[0],t=this._pointerPositions[e];this._onTouchStart({pointerId:e,pageX:t.x,pageY:t.y});break}}function nt(r){let e;switch(r.button){case 0:e=this.mouseButtons.LEFT;break;case 1:e=this.mouseButtons.MIDDLE;break;case 2:e=this.mouseButtons.RIGHT;break;default:e=-1}switch(e){case F.DOLLY:if(this.enableZoom===!1)return;this._handleMouseDownDolly(r),this.state=_.DOLLY;break;case F.ROTATE:if(r.ctrlKey||r.metaKey||r.shiftKey){if(this.enablePan===!1)return;this._handleMouseDownPan(r),this.state=_.PAN}else{if(this.enableRotate===!1)return;this._handleMouseDownRotate(r),this.state=_.ROTATE}break;case F.PAN:if(r.ctrlKey||r.metaKey||r.shiftKey){if(this.enableRotate===!1)return;this._handleMouseDownRotate(r),this.state=_.ROTATE}else{if(this.enablePan===!1)return;this._handleMouseDownPan(r),this.state=_.PAN}break;default:this.state=_.NONE}this.state!==_.NONE&&this.dispatchEvent(se)}function it(r){switch(this.state){case _.ROTATE:if(this.enableRotate===!1)return;this._handleMouseMoveRotate(r);break;case _.DOLLY:if(this.enableZoom===!1)return;this._handleMouseMoveDolly(r);break;case _.PAN:if(this.enablePan===!1)return;this._handleMouseMovePan(r);break}}function ot(r){this.enabled===!1||this.enableZoom===!1||this.state!==_.NONE||(r.preventDefault(),this.dispatchEvent(se),this._handleMouseWheel(this._customWheelEvent(r)),this.dispatchEvent(ge))}function rt(r){this.enabled!==!1&&this._handleKeyDown(r)}function at(r){switch(this._trackPointer(r),this._pointers.length){case 1:switch(this.touches.ONE){case v.ROTATE:if(this.enableRotate===!1)return;this._handleTouchStartRotate(r),this.state=_.TOUCH_ROTATE;break;case v.PAN:if(this.enablePan===!1)return;this._handleTouchStartPan(r),this.state=_.TOUCH_PAN;break;default:this.state=_.NONE}break;case 2:switch(this.touches.TWO){case v.DOLLY_PAN:if(this.enableZoom===!1&&this.enablePan===!1)return;this._handleTouchStartDollyPan(r),this.state=_.TOUCH_DOLLY_PAN;break;case v.DOLLY_ROTATE:if(this.enableZoom===!1&&this.enableRotate===!1)return;this._handleTouchStartDollyRotate(r),this.state=_.TOUCH_DOLLY_ROTATE;break;default:this.state=_.NONE}break;default:this.state=_.NONE}this.state!==_.NONE&&this.dispatchEvent(se)}function ct(r){switch(this._trackPointer(r),this.state){case _.TOUCH_ROTATE:if(this.enableRotate===!1)return;this._handleTouchMoveRotate(r),this.update();break;case _.TOUCH_PAN:if(this.enablePan===!1)return;this._handleTouchMovePan(r),this.update();break;case _.TOUCH_DOLLY_PAN:if(this.enableZoom===!1&&this.enablePan===!1)return;this._handleTouchMoveDollyPan(r),this.update();break;case _.TOUCH_DOLLY_ROTATE:if(this.enableZoom===!1&&this.enableRotate===!1)return;this._handleTouchMoveDollyRotate(r),this.update();break;default:this.state=_.NONE}}function ht(r){this.enabled!==!1&&r.preventDefault()}function lt(r){r.key==="Control"&&(this._controlActive=!0,this.domElement.getRootNode().addEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}function ut(r){r.key==="Control"&&(this._controlActive=!1,this.domElement.getRootNode().removeEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}const ce={POSITION:["byte","byte normalized","unsigned byte","unsigned byte normalized","short","short normalized","unsigned short","unsigned short normalized"],NORMAL:["byte normalized","short normalized"],TANGENT:["byte normalized","short normalized"],TEXCOORD:["byte","byte normalized","unsigned byte","short","short normalized","unsigned short"]};class X{constructor(){this.textureUtils=null,this.pluginCallbacks=[],this.register(function(e){return new Tt(e)}),this.register(function(e){return new Et(e)}),this.register(function(e){return new Rt(e)}),this.register(function(e){return new St(e)}),this.register(function(e){return new It(e)}),this.register(function(e){return new Ct(e)}),this.register(function(e){return new Mt(e)}),this.register(function(e){return new bt(e)}),this.register(function(e){return new At(e)}),this.register(function(e){return new Lt(e)}),this.register(function(e){return new Nt(e)}),this.register(function(e){return new Pt(e)}),this.register(function(e){return new Dt(e)}),this.register(function(e){return new Ot(e)})}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}setTextureUtils(e){return this.textureUtils=e,this}parse(e,t,n,s){const i=new wt,o=[];for(let a=0,c=this.pluginCallbacks.length;a<c;a++)o.push(this.pluginCallbacks[a](i));i.setPlugins(o),i.setTextureUtils(this.textureUtils),i.writeAsync(e,t,s).catch(n)}parseAsync(e,t){const n=this;return new Promise(function(s,i){n.parse(e,s,i,t)})}}const x={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,INT:5124,UNSIGNED_INT:5125,FLOAT:5126,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},$="KHR_mesh_quantization",L={};L[Ne]=x.NEAREST;L[Pe]=x.NEAREST_MIPMAP_NEAREST;L[De]=x.NEAREST_MIPMAP_LINEAR;L[Oe]=x.LINEAR;L[Ue]=x.LINEAR_MIPMAP_NEAREST;L[ke]=x.LINEAR_MIPMAP_LINEAR;L[ve]=x.CLAMP_TO_EDGE;L[Fe]=x.REPEAT;L[ze]=x.MIRRORED_REPEAT;const he={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},dt=new fe,le=12,pt=1179937895,ft=2,ue=8,mt=1313821514,gt=5130562;function j(r,e){return r.length===e.length&&r.every(function(t,n){return t===e[n]})}function yt(r){return new TextEncoder().encode(r).buffer}function xt(r){return j(r.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function _t(r,e,t){const n={min:new Array(r.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(r.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let s=e;s<e+t;s++)for(let i=0;i<r.itemSize;i++){let o;r.itemSize>4?o=r.array[s*r.itemSize+i]:(i===0?o=r.getX(s):i===1?o=r.getY(s):i===2?o=r.getZ(s):i===3&&(o=r.getW(s)),r.normalized===!0&&(o=V.normalize(o,r.array))),n.min[i]=Math.min(n.min[i],o),n.max[i]=Math.max(n.max[i],o)}return n}function ye(r){return Math.ceil(r/4)*4}function ee(r,e=0){const t=ye(r.byteLength);if(t!==r.byteLength){const n=new Uint8Array(t);if(n.set(new Uint8Array(r)),e!==0)for(let s=r.byteLength;s<t;s++)n[s]=e;return n.buffer}return r}function de(){return typeof document>"u"&&typeof OffscreenCanvas<"u"?new OffscreenCanvas(1,1):document.createElement("canvas")}function pe(r,e){if(r.toBlob!==void 0)return new Promise(n=>r.toBlob(n,e));let t;return e==="image/jpeg"?t=.92:e==="image/webp"&&(t=.8),r.convertToBlob({type:e,quality:t})}class wt{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.extensionsRequired={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter r"+be}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map},this.textureUtils=null}setPlugins(e){this.plugins=e}setTextureUtils(e){this.textureUtils=e}async writeAsync(e,t,n={}){this.options=Object.assign({binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},n),this.options.animations.length>0&&(this.options.trs=!0),await this.processInputAsync(e),await Promise.all(this.pending);const s=this,i=s.buffers,o=s.json;n=s.options;const a=s.extensionsUsed,c=s.extensionsRequired,l=new Blob(i,{type:"application/octet-stream"}),u=Object.keys(a),h=Object.keys(c);if(u.length>0&&(o.extensionsUsed=u),h.length>0&&(o.extensionsRequired=h),o.buffers&&o.buffers.length>0&&(o.buffers[0].byteLength=l.size),n.binary===!0){const g=new FileReader;g.readAsArrayBuffer(l),g.onloadend=function(){const p=ee(g.result),f=new DataView(new ArrayBuffer(ue));f.setUint32(0,p.byteLength,!0),f.setUint32(4,gt,!0);const d=ee(yt(JSON.stringify(o)),32),m=new DataView(new ArrayBuffer(ue));m.setUint32(0,d.byteLength,!0),m.setUint32(4,mt,!0);const E=new ArrayBuffer(le),N=new DataView(E);N.setUint32(0,pt,!0),N.setUint32(4,ft,!0);const H=le+m.byteLength+d.byteLength+f.byteLength+p.byteLength;N.setUint32(8,H,!0);const y=new Blob([E,m,d,f,p],{type:"application/octet-stream"}),T=new FileReader;T.readAsArrayBuffer(y),T.onloadend=function(){t(T.result)}}}else if(o.buffers&&o.buffers.length>0){const g=new FileReader;g.readAsDataURL(l),g.onloadend=function(){const p=g.result;o.buffers[0].uri=p,t(o)}}else t(o)}serializeUserData(e,t){if(Object.keys(e.userData).length===0)return;const n=this.options,s=this.extensionsUsed;try{const i=JSON.parse(JSON.stringify(e.userData));if(n.includeCustomExtensions&&i.gltfExtensions){t.extensions===void 0&&(t.extensions={});for(const o in i.gltfExtensions)t.extensions[o]=i.gltfExtensions[o],s[o]=!0;delete i.gltfExtensions}Object.keys(i).length>0&&(t.extras=i)}catch(i){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+i.message)}}getUID(e,t=!1){if(this.uids.has(e)===!1){const s=new Map;s.set(!0,this.uid++),s.set(!1,this.uid++),this.uids.set(e,s)}return this.uids.get(e).get(t)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const n=new w;for(let s=0,i=e.count;s<i;s++)if(Math.abs(n.fromBufferAttribute(e,s).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const t=this.cache;if(t.attributesNormalized.has(e))return t.attributesNormalized.get(e);const n=e.clone(),s=new w;for(let i=0,o=n.count;i<o;i++)s.fromBufferAttribute(n,i),s.x===0&&s.y===0&&s.z===0?s.setX(1):s.normalize(),n.setXYZ(i,s.x,s.y,s.z);return t.attributesNormalized.set(e,n),n}applyTextureTransform(e,t){let n=!1;const s={};(t.offset.x!==0||t.offset.y!==0)&&(s.offset=t.offset.toArray(),n=!0),t.rotation!==0&&(s.rotation=t.rotation,n=!0),(t.repeat.x!==1||t.repeat.y!==1)&&(s.scale=t.repeat.toArray(),n=!0),n&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=s,this.extensionsUsed.KHR_texture_transform=!0)}async buildMetalRoughTextureAsync(e,t){if(e===t)return e;function n(p){return p.colorSpace===Le?function(d){return d<.04045?d*.0773993808:Math.pow(d*.9478672986+.0521327014,2.4)}:function(d){return d}}e instanceof q&&(e=await this.decompressTextureAsync(e)),t instanceof q&&(t=await this.decompressTextureAsync(t));const s=e?e.image:null,i=t?t.image:null,o=Math.max(s?s.width:0,i?i.width:0),a=Math.max(s?s.height:0,i?i.height:0),c=de();c.width=o,c.height=a;const l=c.getContext("2d",{willReadFrequently:!0});l.fillStyle="#00ffff",l.fillRect(0,0,o,a);const u=l.getImageData(0,0,o,a);if(s){l.drawImage(s,0,0,o,a);const p=n(e),f=l.getImageData(0,0,o,a).data;for(let d=2;d<f.length;d+=4)u.data[d]=p(f[d]/256)*256}if(i){l.drawImage(i,0,0,o,a);const p=n(t),f=l.getImageData(0,0,o,a).data;for(let d=1;d<f.length;d+=4)u.data[d]=p(f[d]/256)*256}l.putImageData(u,0,0);const g=(e||t).clone();return g.source=new Ae(c),g.colorSpace=Re,g.channel=(e||t).channel,e&&t&&e.channel!==t.channel&&console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."),console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."),g}async decompressTextureAsync(e,t=1/0){if(this.textureUtils===null)throw new Error("THREE.GLTFExporter: setTextureUtils() must be called to process compressed textures.");return await this.textureUtils.decompress(e,t)}processBuffer(e){const t=this.json,n=this.buffers;return t.buffers||(t.buffers=[{byteLength:0}]),n.push(e),0}processBufferView(e,t,n,s,i){const o=this.json;o.bufferViews||(o.bufferViews=[]);let a;switch(t){case x.BYTE:case x.UNSIGNED_BYTE:a=1;break;case x.SHORT:case x.UNSIGNED_SHORT:a=2;break;default:a=4}let c=e.itemSize*a;i===x.ARRAY_BUFFER&&(c=Math.ceil(c/4)*4);const l=ye(s*c),u=new DataView(new ArrayBuffer(l));let h=0;for(let f=n;f<n+s;f++){for(let d=0;d<e.itemSize;d++){let m;e.itemSize>4?m=e.array[f*e.itemSize+d]:(d===0?m=e.getX(f):d===1?m=e.getY(f):d===2?m=e.getZ(f):d===3&&(m=e.getW(f)),e.normalized===!0&&(m=V.normalize(m,e.array))),t===x.FLOAT?u.setFloat32(h,m,!0):t===x.INT?u.setInt32(h,m,!0):t===x.UNSIGNED_INT?u.setUint32(h,m,!0):t===x.SHORT?u.setInt16(h,m,!0):t===x.UNSIGNED_SHORT?u.setUint16(h,m,!0):t===x.BYTE?u.setInt8(h,m):t===x.UNSIGNED_BYTE&&u.setUint8(h,m),h+=a}h%c!==0&&(h+=c-h%c)}const g={buffer:this.processBuffer(u.buffer),byteOffset:this.byteOffset,byteLength:l};return i!==void 0&&(g.target=i),i===x.ARRAY_BUFFER&&(g.byteStride=c),this.byteOffset+=l,o.bufferViews.push(g),{id:o.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const t=this,n=t.json;return n.bufferViews||(n.bufferViews=[]),new Promise(function(s){const i=new FileReader;i.readAsArrayBuffer(e),i.onloadend=function(){const o=ee(i.result),a={buffer:t.processBuffer(o),byteOffset:t.byteOffset,byteLength:o.byteLength};t.byteOffset+=o.byteLength,s(n.bufferViews.push(a)-1)}})}processAccessor(e,t,n,s){const i=this.json,o={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",9:"MAT3",16:"MAT4"};let a;if(e.array.constructor===Float32Array)a=x.FLOAT;else if(e.array.constructor===Int32Array)a=x.INT;else if(e.array.constructor===Uint32Array)a=x.UNSIGNED_INT;else if(e.array.constructor===Int16Array)a=x.SHORT;else if(e.array.constructor===Uint16Array)a=x.UNSIGNED_SHORT;else if(e.array.constructor===Int8Array)a=x.BYTE;else if(e.array.constructor===Uint8Array)a=x.UNSIGNED_BYTE;else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: "+e.array.constructor.name);if(n===void 0&&(n=0),(s===void 0||s===1/0)&&(s=e.count),s===0)return null;const c=_t(e,n,s);let l;t!==void 0&&(l=e===t.index?x.ELEMENT_ARRAY_BUFFER:x.ARRAY_BUFFER);const u=this.processBufferView(e,a,n,s,l),h={bufferView:u.id,byteOffset:u.byteOffset,componentType:a,count:s,max:c.max,min:c.min,type:o[e.itemSize]};return e.normalized===!0&&(h.normalized=!0),i.accessors||(i.accessors=[]),i.accessors.push(h)-1}processImage(e,t,n,s="image/png"){if(e!==null){const i=this,o=i.cache,a=i.json,c=i.options,l=i.pending;o.images.has(e)||o.images.set(e,{});const u=o.images.get(e),h=s+":flipY/"+n.toString();if(u[h]!==void 0)return u[h];a.images||(a.images=[]);const g={mimeType:s},p=de();p.width=Math.min(e.width,c.maxTextureSize),p.height=Math.min(e.height,c.maxTextureSize);const f=p.getContext("2d",{willReadFrequently:!0});if(n===!0&&(f.translate(0,p.height),f.scale(1,-1)),e.data!==void 0){t!==Se&&console.error("GLTFExporter: Only RGBAFormat is supported.",t),(e.width>c.maxTextureSize||e.height>c.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const m=new Uint8ClampedArray(e.height*e.width*4);for(let E=0;E<m.length;E+=4)m[E+0]=e.data[E+0],m[E+1]=e.data[E+1],m[E+2]=e.data[E+2],m[E+3]=e.data[E+3];f.putImageData(new ImageData(m,e.width,e.height),0,0)}else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap||typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas)f.drawImage(e,0,0,p.width,p.height);else throw new Error("THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.");c.binary===!0?l.push(pe(p,s).then(m=>i.processBufferViewImage(m)).then(m=>{g.bufferView=m})):p.toDataURL!==void 0?g.uri=p.toDataURL(s):l.push(pe(p,s).then(m=>new FileReader().readAsDataURL(m)).then(m=>{g.uri=m}));const d=a.images.push(g)-1;return u[h]=d,d}else throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")}processSampler(e){const t=this.json;t.samplers||(t.samplers=[]);const n={magFilter:L[e.magFilter],minFilter:L[e.minFilter],wrapS:L[e.wrapS],wrapT:L[e.wrapT]};return t.samplers.push(n)-1}async processTextureAsync(e){const n=this.options,s=this.cache,i=this.json;if(s.textures.has(e))return s.textures.get(e);i.textures||(i.textures=[]),e instanceof q&&(e=await this.decompressTextureAsync(e,n.maxTextureSize));let o=e.userData.mimeType;o==="image/webp"&&(o="image/png");const a={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY,o)};e.name&&(a.name=e.name),await this._invokeAllAsync(async function(l){l.writeTexture&&await l.writeTexture(e,a)});const c=i.textures.push(a)-1;return s.textures.set(e,c),c}async processMaterialAsync(e){const t=this.cache,n=this.json;if(t.materials.has(e))return t.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;n.materials||(n.materials=[]);const s={pbrMetallicRoughness:{}};e.isMeshStandardMaterial!==!0&&e.isMeshBasicMaterial!==!0&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const i=e.color.toArray().concat([e.opacity]);if(j(i,[1,1,1,1])||(s.pbrMetallicRoughness.baseColorFactor=i),e.isMeshStandardMaterial?(s.pbrMetallicRoughness.metallicFactor=e.metalness,s.pbrMetallicRoughness.roughnessFactor=e.roughness):(s.pbrMetallicRoughness.metallicFactor=0,s.pbrMetallicRoughness.roughnessFactor=1),e.metalnessMap||e.roughnessMap){const a=await this.buildMetalRoughTextureAsync(e.metalnessMap,e.roughnessMap),c={index:await this.processTextureAsync(a),texCoord:a.channel};this.applyTextureTransform(c,a),s.pbrMetallicRoughness.metallicRoughnessTexture=c}if(e.map){const a={index:await this.processTextureAsync(e.map),texCoord:e.map.channel};this.applyTextureTransform(a,e.map),s.pbrMetallicRoughness.baseColorTexture=a}if(e.emissive){const a=e.emissive;if(Math.max(a.r,a.g,a.b)>0&&(s.emissiveFactor=e.emissive.toArray()),e.emissiveMap){const l={index:await this.processTextureAsync(e.emissiveMap),texCoord:e.emissiveMap.channel};this.applyTextureTransform(l,e.emissiveMap),s.emissiveTexture=l}}if(e.normalMap){const a={index:await this.processTextureAsync(e.normalMap),texCoord:e.normalMap.channel};e.normalScale&&e.normalScale.x!==1&&(a.scale=e.normalScale.x),this.applyTextureTransform(a,e.normalMap),s.normalTexture=a}if(e.aoMap){const a={index:await this.processTextureAsync(e.aoMap),texCoord:e.aoMap.channel};e.aoMapIntensity!==1&&(a.strength=e.aoMapIntensity),this.applyTextureTransform(a,e.aoMap),s.occlusionTexture=a}e.transparent?s.alphaMode="BLEND":e.alphaTest>0&&(s.alphaMode="MASK",s.alphaCutoff=e.alphaTest),e.side===Ie&&(s.doubleSided=!0),e.name!==""&&(s.name=e.name),this.serializeUserData(e,s),await this._invokeAllAsync(async function(a){a.writeMaterialAsync&&await a.writeMaterialAsync(e,s)});const o=n.materials.push(s)-1;return t.materials.set(e,o),o}async processMeshAsync(e){const t=this.cache,n=this.json,s=[e.geometry.uuid];if(Array.isArray(e.material))for(let y=0,T=e.material.length;y<T;y++)s.push(e.material[y].uuid);else s.push(e.material.uuid);const i=s.join(":");if(t.meshes.has(i))return t.meshes.get(i);const o=e.geometry;let a;e.isLineSegments?a=x.LINES:e.isLineLoop?a=x.LINE_LOOP:e.isLine?a=x.LINE_STRIP:e.isPoints?a=x.POINTS:a=e.material.wireframe?x.LINES:x.TRIANGLES;const c={},l={},u=[],h=[],g={uv:"TEXCOORD_0",uv1:"TEXCOORD_1",uv2:"TEXCOORD_2",uv3:"TEXCOORD_3",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},p=o.getAttribute("normal");p!==void 0&&!this.isNormalizedNormalAttribute(p)&&(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),o.setAttribute("normal",this.createNormalizedNormalAttribute(p)));let f=null;for(let y in o.attributes){if(y.slice(0,5)==="morph")continue;const T=o.attributes[y];if(y=g[y]||y.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(y)||(y="_"+y),t.attributes.has(this.getUID(T))){l[y]=t.attributes.get(this.getUID(T));continue}f=null;const b=T.array;y==="JOINTS_0"&&!(b instanceof Uint16Array)&&!(b instanceof Uint8Array)?(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),f=new U(new Uint16Array(b),T.itemSize,T.normalized)):(b instanceof Uint32Array||b instanceof Int32Array)&&!y.startsWith("_")&&(console.warn(`GLTFExporter: Attribute "${y}" converted to type FLOAT.`),f=X.Utils.toFloat32BufferAttribute(T));const I=this.processAccessor(f||T,o);I!==null&&(y.startsWith("_")||this.detectMeshQuantization(y,T),l[y]=I,t.attributes.set(this.getUID(T),I))}if(p!==void 0&&o.setAttribute("normal",p),Object.keys(l).length===0)return null;if(e.morphTargetInfluences!==void 0&&e.morphTargetInfluences.length>0){const y=[],T=[],A={};if(e.morphTargetDictionary!==void 0)for(const b in e.morphTargetDictionary)A[e.morphTargetDictionary[b]]=b;for(let b=0;b<e.morphTargetInfluences.length;++b){const I={};let ne=!1;for(const z in o.morphAttributes){if(z!=="position"&&z!=="normal"){ne||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),ne=!0);continue}const D=o.morphAttributes[z][b],W=z.toUpperCase(),G=o.attributes[z];if(t.attributes.has(this.getUID(D,!0))){I[W]=t.attributes.get(this.getUID(D,!0));continue}const B=D.clone();if(!o.morphTargetsRelative)for(let R=0,xe=D.count;R<xe;R++)for(let k=0;k<D.itemSize;k++)k===0&&B.setX(R,D.getX(R)-G.getX(R)),k===1&&B.setY(R,D.getY(R)-G.getY(R)),k===2&&B.setZ(R,D.getZ(R)-G.getZ(R)),k===3&&B.setW(R,D.getW(R)-G.getW(R));I[W]=this.processAccessor(B,o),t.attributes.set(this.getUID(G,!0),I[W])}h.push(I),y.push(e.morphTargetInfluences[b]),e.morphTargetDictionary!==void 0&&T.push(A[b])}c.weights=y,T.length>0&&(c.extras={},c.extras.targetNames=T)}const d=Array.isArray(e.material);if(d&&o.groups.length===0)return null;let m=!1;if(d&&o.index===null){const y=[];for(let T=0,A=o.attributes.position.count;T<A;T++)y[T]=T;o.setIndex(y),m=!0}const E=d?e.material:[e.material],N=d?o.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let y=0,T=N.length;y<T;y++){const A={mode:a,attributes:l};if(this.serializeUserData(o,A),h.length>0&&(A.targets=h),o.index!==null){let I=this.getUID(o.index);(N[y].start!==void 0||N[y].count!==void 0)&&(I+=":"+N[y].start+":"+N[y].count),t.attributes.has(I)?A.indices=t.attributes.get(I):(A.indices=this.processAccessor(o.index,o,N[y].start,N[y].count),t.attributes.set(I,A.indices)),A.indices===null&&delete A.indices}const b=await this.processMaterialAsync(E[N[y].materialIndex]);b!==null&&(A.material=b),u.push(A)}m===!0&&o.setIndex(null),c.primitives=u,n.meshes||(n.meshes=[]),await this._invokeAllAsync(function(y){y.writeMesh&&y.writeMesh(e,c)});const H=n.meshes.push(c)-1;return t.meshes.set(i,H),H}detectMeshQuantization(e,t){if(this.extensionsUsed[$])return;let n;switch(t.array.constructor){case Int8Array:n="byte";break;case Uint8Array:n="unsigned byte";break;case Int16Array:n="short";break;case Uint16Array:n="unsigned short";break;default:return}t.normalized&&(n+=" normalized");const s=e.split("_",1)[0];ce[s]&&ce[s].includes(n)&&(this.extensionsUsed[$]=!0,this.extensionsRequired[$]=!0)}processCamera(e){const t=this.json;t.cameras||(t.cameras=[]);const n=e.isOrthographicCamera,s={type:n?"orthographic":"perspective"};return n?s.orthographic={xmag:e.right*2,ymag:e.top*2,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:s.perspective={aspectRatio:e.aspect,yfov:V.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},e.name!==""&&(s.name=e.type),t.cameras.push(s)-1}processAnimation(e,t){const n=this.json,s=this.nodeMap;n.animations||(n.animations=[]),e=X.Utils.mergeMorphTargetTracks(e.clone(),t);const i=e.tracks,o=[],a=[];for(let c=0;c<i.length;++c){const l=i[c],u=Z.parseTrackName(l.name);let h=Z.findNode(t,u.nodeName);const g=he[u.propertyName];if(u.objectName==="bones"&&(h.isSkinnedMesh===!0?h=h.skeleton.getBoneByName(u.objectIndex):h=void 0),!h||!g){console.warn('THREE.GLTFExporter: Could not export animation track "%s".',l.name);continue}const p=1;let f=l.values.length/l.times.length;g===he.morphTargetInfluences&&(f/=h.morphTargetInfluences.length);let d;l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline===!0?(d="CUBICSPLINE",f/=3):l.getInterpolation()===Ce?d="STEP":d="LINEAR",a.push({input:this.processAccessor(new U(l.times,p)),output:this.processAccessor(new U(l.values,f)),interpolation:d}),o.push({sampler:a.length-1,target:{node:s.get(h),path:g}})}return n.animations.push({name:e.name||"clip_"+n.animations.length,samplers:a,channels:o}),n.animations.length-1}processSkin(e){const t=this.json,n=this.nodeMap,s=t.nodes[n.get(e)],i=e.skeleton;if(i===void 0)return null;const o=e.skeleton.bones[0];if(o===void 0)return null;const a=[],c=new Float32Array(i.bones.length*16),l=new me;for(let h=0;h<i.bones.length;++h)a.push(n.get(i.bones[h])),l.copy(i.boneInverses[h]),l.multiply(e.bindMatrix).toArray(c,h*16);return t.skins===void 0&&(t.skins=[]),t.skins.push({inverseBindMatrices:this.processAccessor(new U(c,16)),joints:a,skeleton:n.get(o)}),s.skin=t.skins.length-1}async processNodeAsync(e){const t=this.json,n=this.options,s=this.nodeMap;t.nodes||(t.nodes=[]);const i={};if(n.trs){const a=e.quaternion.toArray(),c=e.position.toArray(),l=e.scale.toArray();j(a,[0,0,0,1])||(i.rotation=a),j(c,[0,0,0])||(i.translation=c),j(l,[1,1,1])||(i.scale=l)}else e.matrixAutoUpdate&&e.updateMatrix(),xt(e.matrix)===!1&&(i.matrix=e.matrix.elements);if(e.name!==""&&(i.name=String(e.name)),this.serializeUserData(e,i),e.isMesh||e.isLine||e.isPoints){const a=await this.processMeshAsync(e);a!==null&&(i.mesh=a)}else e.isCamera&&(i.camera=this.processCamera(e));if(e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const a=[];for(let c=0,l=e.children.length;c<l;c++){const u=e.children[c];if(u.visible||n.onlyVisible===!1){const h=await this.processNodeAsync(u);h!==null&&a.push(h)}}a.length>0&&(i.children=a)}await this._invokeAllAsync(function(a){a.writeNode&&a.writeNode(e,i)});const o=t.nodes.push(i)-1;return s.set(e,o),o}async processSceneAsync(e){const t=this.json,n=this.options;t.scenes||(t.scenes=[],t.scene=0);const s={};e.name!==""&&(s.name=e.name),t.scenes.push(s);const i=[];for(let o=0,a=e.children.length;o<a;o++){const c=e.children[o];if(c.visible||n.onlyVisible===!1){const l=await this.processNodeAsync(c);l!==null&&i.push(l)}}i.length>0&&(s.nodes=i),this.serializeUserData(e,s)}async processObjectsAsync(e){const t=new te;t.name="AuxScene";for(let n=0;n<e.length;n++)t.children.push(e[n]);await this.processSceneAsync(t)}async processInputAsync(e){const t=this.options;e=e instanceof Array?e:[e],await this._invokeAllAsync(function(s){s.beforeParse&&s.beforeParse(e)});const n=[];for(let s=0;s<e.length;s++)e[s]instanceof te?await this.processSceneAsync(e[s]):n.push(e[s]);n.length>0&&await this.processObjectsAsync(n);for(let s=0;s<this.skins.length;++s)this.processSkin(this.skins[s]);for(let s=0;s<t.animations.length;++s)this.processAnimation(t.animations[s],e[0]);await this._invokeAllAsync(function(s){s.afterParse&&s.afterParse(e)})}async _invokeAllAsync(e){for(let t=0,n=this.plugins.length;t<n;t++)await e(this.plugins[t])}}class Tt{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,t){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight){console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);return}const n=this.writer,s=n.json,i=n.extensionsUsed,o={};e.name&&(o.name=e.name),o.color=e.color.toArray(),o.intensity=e.intensity,e.isDirectionalLight?o.type="directional":e.isPointLight?(o.type="point",e.distance>0&&(o.range=e.distance)):e.isSpotLight&&(o.type="spot",e.distance>0&&(o.range=e.distance),o.spot={},o.spot.innerConeAngle=(1-e.penumbra)*e.angle,o.spot.outerConeAngle=e.angle),e.decay!==void 0&&e.decay!==2&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),e.target&&(e.target.parent!==e||e.target.position.x!==0||e.target.position.y!==0||e.target.position.z!==-1)&&console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),i[this.name]||(s.extensions=s.extensions||{},s.extensions[this.name]={lights:[]},i[this.name]=!0);const a=s.extensions[this.name].lights;a.push(o),t.extensions=t.extensions||{},t.extensions[this.name]={light:a.length-1}}}class Et{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}async writeMaterialAsync(e,t){if(!e.isMeshBasicMaterial)return;const s=this.writer.extensionsUsed;t.extensions=t.extensions||{},t.extensions[this.name]={},s[this.name]=!0,t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=.9}}class Mt{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.clearcoat===0)return;const n=this.writer,s=n.extensionsUsed,i={};if(i.clearcoatFactor=e.clearcoat,e.clearcoatMap){const o={index:await n.processTextureAsync(e.clearcoatMap),texCoord:e.clearcoatMap.channel};n.applyTextureTransform(o,e.clearcoatMap),i.clearcoatTexture=o}if(i.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const o={index:await n.processTextureAsync(e.clearcoatRoughnessMap),texCoord:e.clearcoatRoughnessMap.channel};n.applyTextureTransform(o,e.clearcoatRoughnessMap),i.clearcoatRoughnessTexture=o}if(e.clearcoatNormalMap){const o={index:await n.processTextureAsync(e.clearcoatNormalMap),texCoord:e.clearcoatNormalMap.channel};e.clearcoatNormalScale.x!==1&&(o.scale=e.clearcoatNormalScale.x),n.applyTextureTransform(o,e.clearcoatNormalMap),i.clearcoatNormalTexture=o}t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}class bt{constructor(e){this.writer=e,this.name="KHR_materials_dispersion"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.dispersion===0)return;const s=this.writer.extensionsUsed,i={};i.dispersion=e.dispersion,t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}class At{constructor(e){this.writer=e,this.name="KHR_materials_iridescence"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.iridescence===0)return;const n=this.writer,s=n.extensionsUsed,i={};if(i.iridescenceFactor=e.iridescence,e.iridescenceMap){const o={index:await n.processTextureAsync(e.iridescenceMap),texCoord:e.iridescenceMap.channel};n.applyTextureTransform(o,e.iridescenceMap),i.iridescenceTexture=o}if(i.iridescenceIor=e.iridescenceIOR,i.iridescenceThicknessMinimum=e.iridescenceThicknessRange[0],i.iridescenceThicknessMaximum=e.iridescenceThicknessRange[1],e.iridescenceThicknessMap){const o={index:await n.processTextureAsync(e.iridescenceThicknessMap),texCoord:e.iridescenceThicknessMap.channel};n.applyTextureTransform(o,e.iridescenceThicknessMap),i.iridescenceThicknessTexture=o}t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}class Rt{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const n=this.writer,s=n.extensionsUsed,i={};if(i.transmissionFactor=e.transmission,e.transmissionMap){const o={index:await n.processTextureAsync(e.transmissionMap),texCoord:e.transmissionMap.channel};n.applyTextureTransform(o,e.transmissionMap),i.transmissionTexture=o}t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}class St{constructor(e){this.writer=e,this.name="KHR_materials_volume"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const n=this.writer,s=n.extensionsUsed,i={};if(i.thicknessFactor=e.thickness,e.thicknessMap){const o={index:await n.processTextureAsync(e.thicknessMap),texCoord:e.thicknessMap.channel};n.applyTextureTransform(o,e.thicknessMap),i.thicknessTexture=o}e.attenuationDistance!==1/0&&(i.attenuationDistance=e.attenuationDistance),i.attenuationColor=e.attenuationColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}class It{constructor(e){this.writer=e,this.name="KHR_materials_ior"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.ior===1.5)return;const s=this.writer.extensionsUsed,i={};i.ior=e.ior,t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}class Ct{constructor(e){this.writer=e,this.name="KHR_materials_specular"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.specularIntensity===1&&e.specularColor.equals(dt)&&!e.specularIntensityMap&&!e.specularColorMap)return;const n=this.writer,s=n.extensionsUsed,i={};if(e.specularIntensityMap){const o={index:await n.processTextureAsync(e.specularIntensityMap),texCoord:e.specularIntensityMap.channel};n.applyTextureTransform(o,e.specularIntensityMap),i.specularTexture=o}if(e.specularColorMap){const o={index:await n.processTextureAsync(e.specularColorMap),texCoord:e.specularColorMap.channel};n.applyTextureTransform(o,e.specularColorMap),i.specularColorTexture=o}i.specularFactor=e.specularIntensity,i.specularColorFactor=e.specularColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}class Lt{constructor(e){this.writer=e,this.name="KHR_materials_sheen"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.sheen==0)return;const n=this.writer,s=n.extensionsUsed,i={};if(e.sheenRoughnessMap){const o={index:await n.processTextureAsync(e.sheenRoughnessMap),texCoord:e.sheenRoughnessMap.channel};n.applyTextureTransform(o,e.sheenRoughnessMap),i.sheenRoughnessTexture=o}if(e.sheenColorMap){const o={index:await n.processTextureAsync(e.sheenColorMap),texCoord:e.sheenColorMap.channel};n.applyTextureTransform(o,e.sheenColorMap),i.sheenColorTexture=o}i.sheenRoughnessFactor=e.sheenRoughness,i.sheenColorFactor=e.sheenColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}class Nt{constructor(e){this.writer=e,this.name="KHR_materials_anisotropy"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.anisotropy==0)return;const n=this.writer,s=n.extensionsUsed,i={};if(e.anisotropyMap){const o={index:await n.processTextureAsync(e.anisotropyMap)};n.applyTextureTransform(o,e.anisotropyMap),i.anisotropyTexture=o}i.anisotropyStrength=e.anisotropy,i.anisotropyRotation=e.anisotropyRotation,t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}class Pt{constructor(e){this.writer=e,this.name="KHR_materials_emissive_strength"}async writeMaterialAsync(e,t){if(!e.isMeshStandardMaterial||e.emissiveIntensity===1)return;const s=this.writer.extensionsUsed,i={};i.emissiveStrength=e.emissiveIntensity,t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}class Dt{constructor(e){this.writer=e,this.name="EXT_materials_bump"}async writeMaterialAsync(e,t){if(!e.isMeshStandardMaterial||e.bumpScale===1&&!e.bumpMap)return;const n=this.writer,s=n.extensionsUsed,i={};if(e.bumpMap){const o={index:await n.processTextureAsync(e.bumpMap),texCoord:e.bumpMap.channel};n.applyTextureTransform(o,e.bumpMap),i.bumpTexture=o}i.bumpFactor=e.bumpScale,t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}class Ot{constructor(e){this.writer=e,this.name="EXT_mesh_gpu_instancing"}writeNode(e,t){if(!e.isInstancedMesh)return;const n=this.writer,s=e,i=new Float32Array(s.count*3),o=new Float32Array(s.count*4),a=new Float32Array(s.count*3),c=new me,l=new w,u=new K,h=new w;for(let p=0;p<s.count;p++)s.getMatrixAt(p,c),c.decompose(l,u,h),l.toArray(i,p*3),u.toArray(o,p*4),h.toArray(a,p*3);const g={TRANSLATION:n.processAccessor(new U(i,3)),ROTATION:n.processAccessor(new U(o,4)),SCALE:n.processAccessor(new U(a,3))};s.instanceColor&&(g._COLOR_0=n.processAccessor(s.instanceColor)),t.extensions=t.extensions||{},t.extensions[this.name]={attributes:g},n.extensionsUsed[this.name]=!0,n.extensionsRequired[this.name]=!0}}X.Utils={insertKeyframe:function(r,e){const n=r.getValueSize(),s=new r.TimeBufferType(r.times.length+1),i=new r.ValueBufferType(r.values.length+n),o=r.createInterpolant(new r.ValueBufferType(n));let a;if(r.times.length===0){s[0]=e;for(let c=0;c<n;c++)i[c]=0;a=0}else if(e<r.times[0]){if(Math.abs(r.times[0]-e)<.001)return 0;s[0]=e,s.set(r.times,1),i.set(o.evaluate(e),0),i.set(r.values,n),a=0}else if(e>r.times[r.times.length-1]){if(Math.abs(r.times[r.times.length-1]-e)<.001)return r.times.length-1;s[s.length-1]=e,s.set(r.times,0),i.set(r.values,0),i.set(o.evaluate(e),r.values.length),a=s.length-1}else for(let c=0;c<r.times.length;c++){if(Math.abs(r.times[c]-e)<.001)return c;if(r.times[c]<e&&r.times[c+1]>e){s.set(r.times.slice(0,c+1),0),s[c+1]=e,s.set(r.times.slice(c+1),c+2),i.set(r.values.slice(0,(c+1)*n),0),i.set(o.evaluate(e),(c+1)*n),i.set(r.values.slice((c+1)*n),(c+2)*n),a=c+1;break}}return r.times=s,r.values=i,a},mergeMorphTargetTracks:function(r,e){const t=[],n={},s=r.tracks;for(let i=0;i<s.length;++i){let o=s[i];const a=Z.parseTrackName(o.name),c=Z.findNode(e,a.nodeName);if(a.propertyName!=="morphTargetInfluences"||a.propertyIndex===void 0){t.push(o);continue}if(o.createInterpolant!==o.InterpolantFactoryMethodDiscrete&&o.createInterpolant!==o.InterpolantFactoryMethodLinear){if(o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),o=o.clone(),o.setInterpolation(Ge)}const l=c.morphTargetInfluences.length,u=c.morphTargetDictionary[a.propertyIndex];if(u===void 0)throw new Error("THREE.GLTFExporter: Morph target name not found: "+a.propertyIndex);let h;if(n[c.uuid]===void 0){h=o.clone();const p=new h.ValueBufferType(l*h.times.length);for(let f=0;f<h.times.length;f++)p[f*l+u]=h.values[f];h.name=(a.nodeName||"")+".morphTargetInfluences",h.values=p,n[c.uuid]=h,t.push(h);continue}const g=o.createInterpolant(new o.ValueBufferType(1));h=n[c.uuid];for(let p=0;p<h.times.length;p++)h.values[p*l+u]=g.evaluate(h.times[p]);for(let p=0;p<o.times.length;p++){const f=this.insertKeyframe(h,o.times[p]);h.values[f*l+u]=o.values[p]}}return r.tracks=t,r},toFloat32BufferAttribute:function(r){const e=new U(new Float32Array(r.count*r.itemSize),r.itemSize,!1);if(!r.normalized&&!r.isInterleavedBufferAttribute)return e.array.set(r.array),e;for(let t=0,n=r.count;t<n;t++)for(let s=0;s<r.itemSize;s++)e.setComponent(t,s,r.getComponent(t,s));return e}};class vt{constructor(e){O(this,"geometryManager",Ye.getInstance());O(this,"renderer");O(this,"scene");O(this,"camera");O(this,"controls");O(this,"sliders");O(this,"render",()=>{this.controls.update(),this.renderer.render(this.scene,this.camera),requestAnimationFrame(this.render)});this.canvas=e,this.renderer=new Be({antialias:!0,preserveDrawingBuffer:!0,canvas:e}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(e.clientWidth,e.clientHeight,!1);const t=75,n=e.clientWidth/e.clientHeight,s=.1,i=1e3;this.camera=new je(t,n,s,i),this.camera.position.set(-150,75,120),this.camera.lookAt(0,0,0),this.scene=new te,this.scene.background=new fe(C.BACKGROUND);const o=new Q(C.WHITE,1);o.position.set(-100,100,100),this.scene.add(o);const a=new Q(C.WHITE,.3);a.position.set(100,50,-50),this.scene.add(a);const c=new Q(C.WHITE,.5);c.position.set(0,100,-100),this.scene.add(c),this.scene.add(new He(2236962)),this.controls=new $e(this.camera,this.renderer.domElement),this.controls.target.set(0,0,0),this.controls.minDistance=10,this.controls.maxDistance=200,this.controls.addEventListener("start",()=>{e.style.cursor="grabbing"}),this.controls.addEventListener("end",()=>{e.style.cursor="grab"}),this.sliders=document.getElementById("sliders"),window.addEventListener("keydown",u=>{(u.key==="s"||u.key==="S")&&this.saveScreenshot()});const l=new X;window.addEventListener("keydown",u=>{if(u.key.toLowerCase()!=="e")return;u.preventDefault();const h={binary:!0,embedImages:!0,maxTextureSize:1/0};l.parse(this.scene,g=>{if(g instanceof ArrayBuffer)this.saveArrayBuffer(g,"scene_export.glb"),console.log(" Export successful: scene_export.glb");else{const p=JSON.stringify(g,null,2),f=new Blob([p],{type:"application/json"}),d=document.createElement("a");d.style.display="none",document.body.appendChild(d),d.href=URL.createObjectURL(f),d.download="scene_export.gltf",d.click(),setTimeout(()=>{URL.revokeObjectURL(d.href),document.body.removeChild(d)},100),console.log(" Export successful: scene_export.gltf")}},h)}),window.addEventListener("resize",this.onWindowResize.bind(this))}saveArrayBuffer(e,t){const n=new Blob([e],{type:"application/octet-stream"}),s=document.createElement("a");s.style.display="none",document.body.appendChild(s),s.href=URL.createObjectURL(n),s.download=t,s.click(),setTimeout(()=>{URL.revokeObjectURL(s.href),document.body.removeChild(s)},100)}saveScreenshot(){const t=this.renderer.domElement.toDataURL("image/png"),n=document.createElement("a");n.href=t,n.download="non-gon-scene.png",n.style.display="none",document.body.appendChild(n),n.click(),document.body.removeChild(n)}makeGridAndAxes(){const n=this.makeClippedAxis(new w(1,0,0),100,C.RED),s=this.makeClippedAxis(new w(-1,0,0),100,C.RED),i=this.makeClippedAxis(new w(0,1,0),100,C.BLUE),o=this.makeClippedAxis(new w(0,-1,0),100,C.BLUE),a=this.makeClippedAxis(new w(0,0,1),100,C.GREEN),c=this.makeClippedAxis(new w(0,0,-1),100,C.GREEN);this.scene.add(n,s,i,o,a,c);const l=this.makeArrowCone(new w(1,0,0),100,C.RED),u=this.makeArrowCone(new w(0,1,0),100,C.BLUE),h=this.makeArrowCone(new w(0,0,1),100,C.GREEN);this.scene.add(l,u,h)}makeClippedAxis(e,t,n){const s=[new w(0,0,0),e.clone().multiplyScalar(t)],i=new Ke().setFromPoints(s),o=new Ve({color:n,linewidth:2});return new Ze(i,o)}makeArrowCone(e,t,n){const o=new Xe(2,4,16),a=new We({color:n}),c=new oe(o,a);o.translate(0,-4/2,0);const l=new w(0,1,0),u=new K().setFromUnitVectors(l,e.clone().normalize());c.applyQuaternion(u);const h=e.clone().setLength(t);return c.position.copy(h),c}makeSlidersSolo(e,t,n){const s=document.createElement("fieldset"),i=document.createElement("legend");i.textContent=e,s.appendChild(i),this.makeShapeCenterSliders(s,e,t),this.makeShapeRotationSliders(s,e,t),this.sliders.appendChild(s)}makeSlidersInteraction(e,t,n){this.makeSlidersInteractionAux(e,t,n),this.makeSlidersInteractionAux(t,e,n)}makeSlidersInteractionAux(e,t,n){const s=document.createElement("fieldset"),i=document.createElement("legend");i.textContent=e.getId(),s.appendChild(i),this.makeShapeCenterSlidersInteraction(s,e,t,n),this.makeShapeRotationSlidersInteraction(s,e,t,n),this.sliders.appendChild(s)}makeShapeCenterSliders(e,t,n){const s=this.geometryManager.getGeometry(t).center;[["Center X: ",s.x,o=>this.geometryManager.changeCenterX(t,o)],["Center Y: ",s.y,o=>this.geometryManager.changeCenterY(t,o)],["Center Z: ",s.z,o=>this.geometryManager.changeCenterZ(t,o)]].forEach(([o,a,c])=>{const l=document.createElement("label");l.textContent=o;const u=document.createElement("input");u.type="range",u.min="-100",u.max="100",u.step="0.01",u.value=a.toString(),u.addEventListener("input",()=>{const h=parseFloat(u.value);this.scene.remove(this.scene.getObjectByName(t)),c(h),this.scene.add(this.geometryManager.getGeometryMesh(t,n,"mesh"))}),l.appendChild(u),e.appendChild(l),e.appendChild(document.createElement("br"))})}makeShapeRotationSliders(e,t,n){const s=this.geometryManager.getGeometry(t).rotation;[["Rotation X: ",s.x,o=>this.geometryManager.changeRotationX(t,o)],["Rotation Y: ",s.y,o=>this.geometryManager.changeRotationY(t,o)],["Rotation Z: ",s.z,o=>this.geometryManager.changeRotationZ(t,o)]].forEach(([o,a,c])=>{const l=document.createElement("label");l.textContent=o;const u=document.createElement("input");u.type="range",u.min="-360",u.max="360",u.step="0.01",u.value=a.toString(),u.addEventListener("input",()=>{const h=parseFloat(u.value);this.scene.remove(this.scene.getObjectByName(t)),c(h),this.scene.add(this.geometryManager.getGeometryMesh(t,n,"mesh"))}),l.appendChild(u),e.appendChild(l),e.appendChild(document.createElement("br"))})}makeShapeCenterSlidersInteraction(e,t,n,s){const i=t.getId(),o=t.getColor(),a=n.getId(),c=n.getColor(),l=this.geometryManager.getGeometry(i).center;[["Center X: ",l.x,h=>this.geometryManager.changeCenterX(i,h)],["Center Y: ",l.y,h=>this.geometryManager.changeCenterY(i,h)],["Center Z: ",l.z,h=>this.geometryManager.changeCenterZ(i,h)]].forEach(([h,g,p])=>{const f=document.createElement("label");f.textContent=h;const d=document.createElement("input");d.type="range",d.min="-100",d.max="100",d.step="0.01",d.value=g.toString(),d.addEventListener("input",()=>{const m=parseFloat(d.value);if(this.scene.remove(this.scene.getObjectByName(i)),p(m),s!==void 0){this.scene.add(this.geometryManager.getGeometryMesh(i,o,"mesh"));const E=this.geometryManager.calculateShortestDistance(i,a);this.scene.remove(this.scene.getObjectByName(this.drawShortestDistance(E[0],E[1],s)))}else this.geometryManager.calculateProximityQuery(i,a)?(this.scene.remove(this.scene.getObjectByName(a)),this.geometryManager.deletePreviousGeometry(a),this.scene.add(this.geometryManager.getGeometryMesh(i,o,"line")),this.scene.add(this.geometryManager.getGeometryMesh(a,c,"line"))):(this.scene.remove(this.scene.getObjectByName(a)),this.geometryManager.deletePreviousGeometry(a),this.scene.add(this.geometryManager.getGeometryMesh(i,o,"mesh")),this.scene.add(this.geometryManager.getGeometryMesh(a,c,"mesh")))}),f.appendChild(d),e.appendChild(f),e.appendChild(document.createElement("br"))})}makeShapeRotationSlidersInteraction(e,t,n,s){const i=t.getId(),o=t.getColor(),a=n.getId(),c=n.getColor(),l=this.geometryManager.getGeometry(i).rotation;[["Rotation X: ",l.x,h=>this.geometryManager.changeRotationX(i,h)],["Rotation Y: ",l.y,h=>this.geometryManager.changeRotationY(i,h)],["Rotation Z: ",l.z,h=>this.geometryManager.changeRotationZ(i,h)]].forEach(([h,g,p])=>{const f=document.createElement("label");f.textContent=h;const d=document.createElement("input");d.type="range",d.min="-360",d.max="360",d.step="0.01",d.value=g.toString(),d.addEventListener("input",()=>{const m=parseFloat(d.value);if(this.scene.remove(this.scene.getObjectByName(i)),p(m),s!==void 0){this.scene.add(this.geometryManager.getGeometryMesh(i,o,"mesh"));const E=this.geometryManager.calculateShortestDistance(i,a);this.scene.remove(this.scene.getObjectByName(this.drawShortestDistance(E[0],E[1],s)))}else this.geometryManager.calculateProximityQuery(i,a)?(this.scene.remove(this.scene.getObjectByName(a)),this.geometryManager.deletePreviousGeometry(a),this.scene.add(this.geometryManager.getGeometryMesh(i,o,"line")),this.scene.add(this.geometryManager.getGeometryMesh(a,c,"line"))):(this.scene.remove(this.scene.getObjectByName(a)),this.geometryManager.deletePreviousGeometry(a),this.scene.add(this.geometryManager.getGeometryMesh(i,o,"mesh")),this.scene.add(this.geometryManager.getGeometryMesh(a,c,"mesh")))}),f.appendChild(d),e.appendChild(f),e.appendChild(document.createElement("br"))})}onWindowResize(){const e=this.canvas.clientWidth,t=this.canvas.clientHeight;(this.canvas.width!==e||this.canvas.height!==t)&&(this.renderer.setSize(e,t,!1),this.camera.aspect=e/t,this.camera.updateProjectionMatrix())}startAnimation(){this.buildScene(),this.render()}drawShortestDistance(e,t,n){console.log(e,t);const s=new qe({color:n,lineWidth:1.75}),i=new Qe;i.setPoints([new w(parseFloat(e.x.toFixed(3)),parseFloat(e.y.toFixed(3)),"z"in e?parseFloat(e.z.toFixed(3)):0),new w(parseFloat(t.x.toFixed(3)),parseFloat(t.y.toFixed(3)),"z"in t?parseFloat(t.z.toFixed(3)):0)]);const o=new oe(i,s);return o.name="connection",this.scene.add(o),o.name}}export{vt as B};
